---
layout: post
title:  "g++ 静态链接"
category: [compile]
tags: [g++, linking, static]
---

链接就是指把各个独立但不完整的模块组装成一个可执行文件的过程。

```
aaa.o  ----|  链接
bbb.a  ----|-------> 可执行文件
ccc.so  ---|
```

>链接主要要处理的工作是将各个模块之间相互引用的部分都处理里，使得各个模块之间能够正确地衔接。

静态链接主要包括这些步骤：地址和空间分配（address and storage allocation）、符号解析(symbol resolution)、重定位（relocation）

<!-- more -->

#### 一、地址和空间分配

地址：符号在可执行文件是占用的大小  
空间：可执行文件加载到内存后，符号所在的虚拟地址空间（VMA）  

##### 1.地址分配
如上文所说，输入链接器的是多个目标文件（ELF），需要把多个ELF文件合并成一个新的ELF。  
合并ELF所采用的策略是相同段合并。  
![](http://images.cnitblog.com/blog/407509/201312/18104333-2a9fb85d57b44882bd7e52a3583aa393.png)

##### 1.5 符号冲突

两个ELF拥有同一个外部符号，合并的时候怎样取舍？  
这里使用了[“强符号/弱符号”](http://windmissing.github.io/compile/2015-04/symbol-confliction-in-normal-target-file.html)原则。

##### 2.段空间（VMA）分配

链接前，所有段的VMA都是0。形成可执行文件后，才会给各个段分配VMA。  
可以使用`objdump -h a.o`查看。  
 - 链接前  
![](http://www.68idc.cn/help/uploads/allimg/130724/1ZH4W16_1.jpg)
 - 链接后  
![](http://image.lxway.com/upload/f/56/f565d04fb86f3b87e50072d6aef41da0_thumb.png)  
VMA的起始地址遵守操作系统的进程虚拟地址空间的分配规则。  

##### 3.符号空间分配

各个段的VMA确定了，而所有符号在各个段内的偏移也是已经的，就可以确定每个符号的VMA了。  

#### 二、符号解析

符号解析是为符号重定位做准备的。  
对于所有需要做重定义的符号（外部符号），符号解析器会通过查找全局符号表（新生成的ELF），找到这些符号的目标地址

#### 三、重定位

##### 重定位

在链接之前的编译过程中，那些外部符号的地址还是未知的，编译器是如何引用这些外部符号的呢？  
此时编译器并不知道这些外部符号的地址，所以它使用了一个临时地址来代替外部符号地址。  
符号解析完成后，链接器知道了外部符号的地址，就把这些临时地址替换为真实地址。  


##### 重定位表

记录哪些符号需要重定位
