---
layout: post
title: "linux中内存泄漏的检测（一）"
category: linux
tags: [linux, memory leak]
---

内存泄漏是指程序动态申请的内存在使用完后没有释放，导致这段内存不能被操作系统回收再利用。
例如这段程序，申请了4个字节的空间但没有释放，有4个字节的内存泄漏。

```c++
#include <iostream>
using namespace std;

int main()
{
     int *p = new int(1);
     cout <<*p<<endl;
     return 0
}
```
<!-- more -->

随着时间的推移，泄漏的内存越来越多，可用的内存越来越少，轻则性能受损，重则系统崩溃。

一般情况下，当发生内存泄漏时，系统重启一下就可以把泄漏的内存收回了。但是对于linux，通常跑的是服务器程序，不可以随意重启，内存泄漏的问题就变得更加严重了。

偏偏内存泄漏问题并不好查，因为它难复现（要运行到足够长的时间才会出现）、难定位（出错位置也是随机的，看不出与内存泄漏的位置有什么联系）。

本文将提供几个不同难度的检测内存泄漏方法，并分析其优点缺点

#### 一、最简单的方法

为了避免写出内存泄漏的程序，通常会有这样的编程规范，要求我们在写程序时申请和释放成对出现的。因为每一次申请都意味着应该有一次释放与它相对应。

我们可以利用这个特点，在代码中统计申请和释放的次数，如果申请和释放的数量不同，就认为是内存泄漏了。

```c
#include "stdio.h"
#include "stdlib.h"

int count;

void * my_malloc(int size)
{
     count++;
     return malloc(size);
}
void my_free(void *p)
{
     count--;
     free(p);
}
int main()
{
     count = 0;
     int *p1 = (int *)my_malloc(sizeif(int))
     int *p2 = (int *)my_malloc(sizeif(int))
     printf("%d, %d", p1, p2);
     my_free(p1);
     if(count != 0)
         printf("memory leak!\n");
     return 0
}
```

本文将从方便性、全面性、准确性这几个方面来分析这种方法。

- 方便性：

|功能|是否支持|说明
|:---:|:---:|:---:| 
|运行时检查|否|该方法要求运行结束时对运行中产生的打印分析才能知道结果。
|修改是否方便|否|该方法要求封装所有申请和释放空间的函数，并在调用的地方修改成调用封装后的函数。虽然C中申请/释放内存接口并不多，但是对于一个大型的项目，调用这些接口的地方却是很多的，要全部替换是一个比较大的工作量。
|使用是否方便|否|在使用该方法检测内存泄漏时，要把所有接口换成调试接口，而在发布版本中，这种接口又要被替换回来。

 - 全面性：

|功能|是否支持|说明
|:---:|:---:|:---:| 
|C接口是否可以统一处理|否|C的每个接口都需要分别写封装函数
|C++接口是否可以统一处理|否|C++的接口却无法处理
|动态库与静态库的内存泄漏是否可以检测到|否|如果要检测所调用的库，需要修改库的代码

- 准确性：

|功能|是否支持|说明
|:---:|:---:|:---:| 
|是否会有检测不到的情况|否|这一方法只能用于C，而在C中不会出现申请和释放的大小不一样的情况，所以只要次数一样就不会有问题了
|是否可以定位到行|否|
|是否可以确定泄漏空间的大小|否|

这种方法虽然简单的，却有许多的不足，无法真正应用于项目中。欲知怎样改进，且看下回分解。
