---
layout: post
title:  "g++ 动态链接"
category: [compile]
tags: [g++, linking, 动态链接]
---

#### 一、引入动态链接是为了解决什么问题？

##### 1、空间浪费问题

如果内存中的两个进程都链接了同一静态库，那么这个静态库在两个进程各有一份拷贝，这就造成了内存空间浪费。  

##### 2、更新困难问题

一个库改动后，要通知所有使用它的程序更新库并重新编译。  
使用程序的用户也要把编译好的程序全部重新下载才能使用。  

##### 3、动态链接的解决方案

静态链接是在编译时就把程序主要模块与库链接成一个整体，在运行时把这个整体加载到内存中去的。  
和静态链接不同的时，在编译阶段，链接器仅仅完成部分符号解析工作，程序主要模块和库并不一个整体。运行时，把程序主要模块和库分别加载到内存，然后再做链接工作。  
加载后的链接给程序增加了很多灵活性。（1）如果程序要用到的库已经在内存中，就不用重新加载。（2）如果更新了库，只需要把库加载到内存即可，下次启动程序时，就会链接新的库了。  

<!-- more -->

#### 二、生成动态链接库

##### 地址无关代码

什么是地址无关代码？  
希望程序模块中共享的指令部分在装载时不需要因为装载地址的改而改变，于是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起。这种方案被称为地址无关代码（PIC）。  
地址无关代码与动态链接库什么关系？  
没有使用PIC的动态链接库，能够在运行时链接，解决“更新困难”的问题。但每个进程使用它时都有一份自己的副本，不能解决“空间浪费”的问题。  
使用了PIC的动态链接库，在运行时链接，能够解决“更新困难”的问题。各个进程共享库的指令部分，每个进程有一份库的数据的副本，能够减少“空间浪费”。  
因此，在生成动态链接库时，通常都会使用PIC技术。  
这样说明有点抽象，对比静态链接库。静态链接库的重定向步骤就是在程序确定了装载地址后对部分指令（包含外部符号的地址）做修改，这就不是地址无关代码。  
为什么动态链接器需要PIC技术？  
讲在《动态库加载到内存》部分说明  

##### 使用PIC生成动态链接库

文件内的static函数调用  
文件内的函数调用使用的是相对地址跳转。  
不管库的装载地址是什么，指令之间的相对地址不会改变。  
因此这类型的指令不需要特殊处理  
  
文件内的static数据访问  
访问文件内的数据也使用相对寻址的方式。  
任何一条指令与它要访问的内部数据之间的相对位置是固定的，与装载地址无关。  
因此这类型的指令不需要特殊处理

文件外的数据访问  
文件外的数据包括三种：（1）同一模块（动态库）其它文件的数据、（2）其它模块（别的动态库或包含main的主要模块）中的数据、（3）本文件定义的非static全局数据  
这类数据的目标地址要等到装载时才能确定。那么访问这类数据的指令就不是地址无关代码。

```
 指令   --->  数据地址  ---> 数据
------       ----------
 需要         与装载地
 修改         址有关
```
解决方案：  


```
 指令   --->   GOT下标  --->|
                            | ---> 数据地址 ---> 数据 
               GOT基址  --->|
```
修改后的指令不再直接存数据地地址，而是通过一个表去查询数据的地址。这个表GOT就是全局符号表。  
每个数据在表中的下标是固定的，与装载地址无关。GOT基地的获取可以参考上方《文件内的数据访问》，也是与装载地址无关的。这样这个指令就成了地址无关代码了。  
数据的实际地址存储在GOT表中。但GOT表是数据，每个进程各自有一份副本，不需要共用，也不需要满足地址无关。  
剧透一下，在动态链接库的的重定向过程，不是更新指令中的地址，而是更新GOT中的地址。  
  
文件外的函数调用  
文件外函数包括三种（1）同一模块（动态库）其它文件的函数、（2）其它模块（别的动态库或包含main的主要模块）中的函数、（3）本文件定义的非static函数  
这类函数与文件外的数据类型，那么向这类函数地址跳转的指令都是地址有关的。

```
 跳转指令   --->  函数地址  --->  函数第一条指令
----------       ----------
 需要修改       与装载地址有关
```
解决方案也与文件外的数据访问类型，就是借助于GOT  

```
跳转指令   --->   GOT下标  --->|
                               | ---> 函数地址 ---> 函数第一条指令 
                  GOT基址  --->|
```

#### 三、动态库与主模块的第一次链接

动态库与主模块的链接是在运行时进行的。但是。。。  
在编译生成可执行文件时，或是在ld时，如果有用到动态库，也是要写进来的。  
这时的动态库起了什么作用？  

在编译生成可执行文件的过程中，需要符号解析和重定向两个步骤。  
符号解析即找到外部符号的地址。  
重定向即更新指令中引用这些地址的部分。  
如果符号解析过程中，外部符号找到不到，有两种可能：（1）确定没有定义（2）在动态库中定义  
在ld过程中，动态库会准备一张表，包含它们能提供的所有符号。当主要模块找不到某个符号时会查看这张表。若找到，则对符号做特殊处理，符号解析与重定位时跳过这个符号。若没找到，则报错。  

#### 四、动态链接

走到这里，主要模块已经加载到内存并开始执行，动态库还未加载。  

##### 动态链接器自举

在所有需要加载的动态库中，第一个要加载的一定时“动态库链接器”。  
动态链接器是一个特殊的动态库，它可以执行。主要模块加载动态链接器并把控制权转交给它。
动态链接器是一个个性坚强的动态库，它独立完成对自己的装载、链接、重定位。  
动态链接器一个非常坚忍的动态库，它在完成自己的重定位之前，它的代码不能使用全局变量和函数调用。  

##### 加载其它所需要的.so

动态链接器完成自举会开始加载别的动态库（广度优先）。  
动态库加载和装载的过程比较复杂，将在下方《动态库加载到内存》中单独描述。  

##### 符号解析

动态库加载并分配虚拟地址后后，动态链接器对动态库做符号解析。  
这里把加载和符号解析分开讲，实际过程是连着的。一个动态库加载和解析后，再加载和解析另一个动态库。  

动态链接器保存一个全局符号表GST。  
动态链接器把主要模块与链接器本身的可引出符号主到GST中。
动态链接器把装载进来的动态库的符号表合并到GST中。
如果GST和动态库包含同一符号，则使用GST中的，丢弃动态库中的。（先来后到）  

##### 重定位和初始化

动态链接器再次遍历主要模块与其它动态库，依次对它们做重定向工作。
（1）修改主要模块的指令中引用外部符号的地址  
（2）修改动态库GOT中引用外部符号的地址  
这些外部符号的地址已经存储在GST中。

如果动态库有.init段，动态链接器会执行动态库的.init段  

链接工作结束后，动态链接把控制权归还给主要模块。  

#### 五、动态库加载到内存

走到这里，说明主要模块已经开始执行。动态链接链接器加载装载且取得控制权。动态链接器开始加载其它动态库。  

##### 分配物理内存地址

当内存中没有程序需要的动态库时，就分配一块合适大小的物理内存，并把动态库加载到内存  

##### 分配虚拟地址空间

把到动态库与主要模块链接到一起，先要把动态库装载到主要模块所在的虚拟地址空间。（每个进程拥有3G的独立的虚拟地址空间）。
装载过程分为指令部分和数据部分。  
指令部分是所有进程共享的。在内存中只有一份副本。只是作了进程虚拟空间与实际内存空间之间的映射。  
数据部分是每个进程在自己的虚拟地址空间有一份拷贝的。
这个，动态库的所有指令和数据都分配了虚拟地址了。  

上文提到了PIC技术，就是为分配虚拟地址空间做准备的。为什么在这里需要指令满足装载地址无关呢？  
我们已知，（1）所有进程共享动态的指令部分（2）动态库指令的虚拟地址是它相对于各个进程的虚拟地址，也是说，尽管它的实际物理地址是确定的，但它在各个进程的虚拟地址是不同的。  
如果指令的内容与装载的虚拟地址有关，就无法做到所有进程共享了。  
#### 名词说明
主要模块：包含main的可执行程序  
重定向：更新外部符号的地址
