<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>windmissing</title>
    <description>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</description>
    <link>http://yourdomain.com/</link>
    <atom:link href="http://yourdomain.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 13 Dec 2015 21:54:23 +0800</pubDate>
    <lastBuildDate>Sun, 13 Dec 2015 21:54:23 +0800</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>9.1-1求第二小元素</title>
        <description>&lt;h1&gt;一、题目描述&lt;/h1&gt;

&lt;p&gt;证明：在最坏情况下，利用n+ceil(lgn)-2次比较，即可得到n个元素中的第2小元素。（提示：同时找最小元素）&lt;/p&gt;

&lt;h1&gt;二、常规方法&lt;/h1&gt;

&lt;p&gt;使用两次for循环，分别将数组从前往后扫描。
第一扫次扫描过程中，不断记录和更新当前情况下的最小元素。
第二次和扫描过程中，不断记录和更新当前情况下的第二小元素。
伪代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Int min = array[0], minId = 0;
FOR i in [1, n), i++
DO
    IF (array[i] &amp;lt; min)
    DO
        Min = array[i];
        minId = i;
    DONE 
DONE
Int secId = ( minId = 0 ? 1 : 0 ), sec = array[secId];
FOR i in [secId+1, n), i++
DO
    IF (i = minId) CONTINUE
    IF ( array[i] &amp;lt; sec )
    DO
        Sec = array[i];
        secId = i;
    DONE
DONE
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;三、常规方法的比较次数&lt;/h1&gt;

&lt;p&gt;第一个循环过程中，每次循环内部的比较次数为1次，循环次数即扫描的元素个数为n-1，因此比较第一次循环过程的次数是n-1。
第二个循环过程中，每次循环内部的比较次数也中1次，循环次数即扫描的元素个数为n-2（去去掉了最小元素），因此比较第二次循环过程的次数是n-2。
常规方法的比较次数为(n-1)+(n-2)，即2n-3次。&lt;/p&gt;

&lt;h1&gt;四、方法改进一&lt;/h1&gt;

&lt;p&gt;在第一次循环求最小元素的过程时，对元素内容一无所知，因此n-1次的比较是必要的，难有优化空间。
在第二次循环求第二小元素的过程时，对元素的内容不再是一无所知。如果充分利用第一次循环所得到的信息，也许可以省掉第二次循环中不必要的比较。
本次优化的重点在第二次循环。&lt;/p&gt;

&lt;h1&gt;五、第一次循环的可用信息&lt;/h1&gt;

&lt;p&gt;原理：
如果 a &gt; b 且 b &gt; c，那么不需要经过a和c的比较就可以知道 a &gt; c。
信息1：
假设数组中的元素为a, b, c, d, e, f, g … 。
当扫描到元素d时，最小元素为c，可知 a &gt; c, b &gt; c, d &gt; c。
当扫描到元素e时，最小元素变为了e，可知 e &gt; c。
那么 a &gt; c &gt; e, b &gt; c &gt; e, d &gt; c &gt; e，
a,b,d不可能是第二小元素或最小元素
c是第二小元素，e是最小元素
信息2：
接着上文继续扫描，当扫描到元素e时，最小元素为e，结论如上。
当扫描到元素g时，最小元素仍为e，可知f &gt; e, g &gt; e。
那么a &gt; c &gt; e, b &gt; c &gt; e, d &gt; c &gt; e, f &gt; e, g &gt; e
a, b, d不可能是第二小元素或最小元素
c, f, g有可能是第二小元素，e是最小元素&lt;/p&gt;

&lt;h1&gt;六、根据第一遍的可用信息作第二次循环&lt;/h1&gt;

&lt;p&gt;假设已经作过第一次扫描，找到了最小元素，为e，现在要充分利用第一次扫描的信息作第二次扫描。
这一次，我们并不是对除了e以外的所有元素扫描，而是只选择其中一部分。选择的依据来自于上一节的内容。
我们大胆猜测，第二小元素的候选值是那些在第一次扫描过程中与e做过直接比较的元素。
证明如下：
1.  在第一次循环的过程中，第二小元素一定与最后元素e直接比较过。
证明：
第一种情况，在数组顺序中，第二小元素在e之前出现
在出现之前，第二小元素一直都是被当作当前状态的最小元素，遇到e之后，因为与e比较失败，最小元素才变成了e。
第二种情况，在数组顺序中，第二小元素在e之后出现
e会与后面的每一个元素直接比较。
2.  没有与最小元素e直接比较过的元素一定不会是第二小元素
证明过程与1相反，略。&lt;/p&gt;

&lt;h1&gt;七、方法改进一的伪代码&lt;/h1&gt;

&lt;p&gt;第一次扫描的比较没有改变，只是每次比较的过程记录下来，以便第二次扫描的时候知道某个元素曾经和谁做过比较。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Int min = array[0], minId = 0;
FOR i in [1, n), i++
DO
    IF (array[i] &amp;lt; min)
    DO
        Min = array[i];
        minId = i;
        QUEUE[i].PUSH(min);
    ELSE
        QUEUE[minId].push(array[i]);
    DONE 
DONE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二次扫描时，仅取出最小元素所对应的队列元素做比较&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Int secId = QUEUE[minId].ELEMET(0)
FOR i in [1, QUEUE[minId].size), i++
DO
    IF (QUEUE[minId].ELEMET(i) &amp;lt; sec )
    DO
        Sec = QUEUE[minId].ELEMET(i);
    DONE
DONE
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;八、方法改进一的比较次数&lt;/h1&gt;

&lt;p&gt;第一次扫描的次数仍然为n-1，主要差别在于第二次扫描。
第二次扫描也是FOR循环，每次循环内部的比较次数是1次，总的比较次数取决于 队列中元素的个数。假设个数为m，那么比较次数为m-1。
为了计算m，我画了这样一个图。叶子结点为数组中的元素。没有标字母的节点表示其它两个孩子结点的比较结果。画出这样的图，任假设一个结点为最小元素，都能很清晰地看出其队列中元素的个数。
&lt;img src=&quot;http://img.blog.csdn.net/20151112103633333?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;这里写图片描述&quot; /&gt;
我们取两种最极端的情况：
假如最小元素为A，那么其队列中的元素为B, C, D，3个元素
假如最小元素为D，那么其队列中的元素为A, B, C中的最小值，1个元素。
结论，方法改进一的比较次数最多为2n-3，最少为n-1，取决于最小元素所在位置。&lt;/p&gt;

&lt;h1&gt;九、方法改进二&lt;/h1&gt;

&lt;p&gt;虽然方法改进一相比于常规方法是有了改善，但最多比较次数仍然需要2n-3次，未达到题目所要求。这次我们方找最小元素的过程入手。
上文已经说过，求最元素的过程到少要经过n-1次比较，这一点是难以改变的。但我们仍可以通过调整第一次遍历方式，使留给第二次遍历更多有用的信息。尽量让每个元素与其它元素的比较次数平均化，这样，当任意一个元素成为最小元素时，它的队列的元素个数都不会太多。仍然以上文的图为例：
&lt;img src=&quot;http://img.blog.csdn.net/20151112103655088?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;这里写图片描述&quot; /&gt;
方法改进一的第一次遍历可以画成这一样的图，数组中的每一元素是这个二叉树的叶子结点。假如某一个元素是最小元素，那么它的队列的元素即该叶子结点的高度。只要将树平均化，如下图所示，保证每一个叶子的高度都不会太高，那么每个元素对应的队列都就不会太大。
 &lt;img src=&quot;http://img.blog.csdn.net/20151112103711141?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;这里写图片描述&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;十、方法改进二的比较次数&lt;/h1&gt;

&lt;p&gt;方法改进二的伪代码比较复杂，请大家直接阅读源代码。
对于第一次遍历，比较次数仍为n-1。
对于第二次遍历，比较次数取决于第一次遍历转化生成的二叉树的高度h。
将二叉树平均化以后，树的高度为h= ceil[lgn]。
结论，方法改进二的比较次数最多为n+ ceil[lgn]-2。&lt;/p&gt;

&lt;h1&gt;十一、代码&lt;/h1&gt;

&lt;p&gt;产品代码
https://code.csdn.net/mishifangxiangdefeng/exerciseforalgorithmsecond/tree/master/src/chapter9/Exercise9_1_1.cpp
测试代码
https://code.csdn.net/mishifangxiangdefeng/exerciseforalgorithmsecond/tree/master/tst/chapter9/Exercise9_1_1Test.cpp&lt;/p&gt;
</description>
        <pubDate>Sun, 13 Dec 2015 20:00:30 +0800</pubDate>
        <link>http://yourdomain.com/algorithm/2015/12/13/9.1-1-second_smallest_element.html</link>
        <guid isPermaLink="true">http://yourdomain.com/algorithm/2015/12/13/9.1-1-second_smallest_element.html</guid>
        
        
        <category>algorithm</category>
        
      </item>
    
      <item>
        <title>Welcome to Jekyll!</title>
        <description>&lt;p&gt;You’ll find this post in your &lt;code&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;p&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;Tom&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints &#39;Hi, Tom&#39; to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;Check out the &lt;a href=&quot;http://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Thu, 10 Dec 2015 20:22:30 +0800</pubDate>
        <link>http://yourdomain.com/jekyll/update/2015/12/10/welcome-to-jekyll.html</link>
        <guid isPermaLink="true">http://yourdomain.com/jekyll/update/2015/12/10/welcome-to-jekyll.html</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
  </channel>
</rss>
